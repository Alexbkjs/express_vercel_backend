"use strict";
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function removeUndefined(object) {
  const result = {};
  for (const key in object) {
    const v = object[key];
    if (v !== void 0) {
      result[key] = v;
    }
  }
  return result;
}
function serializeUser(user) {
  return user ? JSON.stringify({
    added_to_attachment_menu: user.addedToAttachmentMenu,
    allows_write_to_pm: user.allowsWriteToPm,
    first_name: user.firstName,
    id: user.id,
    is_bot: user.isBot,
    is_premium: user.isPremium,
    language_code: user.languageCode,
    last_name: user.lastName,
    photo_url: user.photoUrl,
    username: user.username
  }) : void 0;
}
function initDataToSearchParams({
  chat,
  receiver,
  user,
  ...data
}) {
  var _a;
  return new URLSearchParams(
    removeUndefined({
      auth_date: data.authDate ? (+data.authDate / 1e3 | 0).toString() : void 0,
      can_send_after: (_a = data.canSendAfter) == null ? void 0 : _a.toString(),
      chat: chat ? JSON.stringify({
        id: chat.id,
        type: chat.type,
        title: chat.title,
        photo_url: chat.type,
        username: chat.username
      }) : void 0,
      chat_instance: data.chatInstance,
      chat_type: data.chatType || void 0,
      hash: data.hash,
      query_id: data.queryId,
      receiver: serializeUser(receiver),
      start_param: data.startParam || void 0,
      user: serializeUser(user)
    })
  );
}
function sign(data, key, authDate, signData2, options) {
  const sp = initDataToSearchParams({
    ...data,
    authDate
  });
  const pairs = [...sp.entries()].map(([name, value]) => `${name}=${value}`).sort();
  function processSign2(s) {
    sp.append("hash", s);
    return sp.toString();
  }
  const sign2 = signData2(pairs.join("\n"), key, options);
  return typeof sign2 === "string" ? processSign2(sign2) : sign2.then(processSign2);
}
function signData(data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? key : hashToken(key, createHmac);
  if (keyHmac instanceof Promise) {
    return keyHmac.then((v) => createHmac(data, v)).then((v) => v.toString("hex"));
  }
  const hmac = createHmac(data, typeof keyHmac === "string" ? Buffer.from(keyHmac, "hex") : keyHmac);
  return hmac instanceof Promise ? hmac.then((v) => v.toString("hex")) : hmac.toString("hex");
}
function processSign(actual, expected) {
  if (actual !== expected) {
    throw new Error("Signature is invalid");
  }
  return;
}
function validate(value, token, signData2, options = {}) {
  let authDate;
  let hash;
  const pairs = [];
  new URLSearchParams(
    typeof value === "string" || value instanceof URLSearchParams ? value : initDataToSearchParams(value)
  ).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      const authDateNum = parseInt(value2, 10);
      if (Number.isNaN(authDateNum)) {
        throw new TypeError('"auth_date" should present integer');
      }
      authDate = new Date(authDateNum * 1e3);
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    throw new Error('"hash" is empty or not found');
  }
  if (!authDate) {
    throw new Error('"auth_date" is empty or not found');
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    if (+authDate + expiresIn * 1e3 < Date.now()) {
      throw new Error("Init data expired");
    }
  }
  pairs.sort();
  const sign2 = signData2(pairs.join("\n"), token, options);
  return typeof sign2 === "string" ? processSign(sign2, hash) : sign2.then((v) => processSign(v, hash));
}
class V extends Error {
  constructor(e, t, n) {
    super(t, { cause: n }), this.type = e, Object.setPrototypeOf(this, V.prototype);
  }
}
function f(s, e, t) {
  return new V(s, e, t);
}
const Ye = "ERR_UNEXPECTED_TYPE", ce = "ERR_PARSE";
function E() {
  return f(Ye, "Value has unexpected type");
}
class D {
  constructor(e, t, n) {
    this.parser = e, this.isOptional = t, this.type = n;
  }
  /**
   * Attempts to parse passed value
   * @param value - value to parse.
   * @throws {SDKError} ERR_PARSE
   * @see ERR_PARSE
   */
  parse(e) {
    if (!(this.isOptional && e === void 0))
      try {
        return this.parser(e);
      } catch (t) {
        throw f(
          ce,
          `Unable to parse value${this.type ? ` as ${this.type}` : ""}`,
          t
        );
      }
  }
  optional() {
    return this.isOptional = true, this;
  }
}
function S(s, e) {
  return () => new D(s, false, e);
}
const b = S((s) => {
  if (typeof s == "boolean")
    return s;
  const e = String(s);
  if (e === "1" || e === "true")
    return true;
  if (e === "0" || e === "false")
    return false;
  throw E();
}, "boolean");
function pe(s, e) {
  const t = {};
  for (const n in s) {
    const r = s[n];
    if (!r)
      continue;
    let i, o;
    if (typeof r == "function" || "parse" in r)
      i = n, o = typeof r == "function" ? r : r.parse.bind(r);
    else {
      const { type: a } = r;
      i = r.from || n, o = typeof a == "function" ? a : a.parse.bind(a);
    }
    try {
      const a = o(e(i));
      a !== void 0 && (t[n] = a);
    } catch (a) {
      throw f(ce, `Unable to parse field "${n}"`, a);
    }
  }
  return t;
}
function he(s) {
  let e = s;
  if (typeof e == "string" && (e = JSON.parse(e)), typeof e != "object" || e === null || Array.isArray(e))
    throw E();
  return e;
}
function g(s, e) {
  return new D((t) => {
    const n = he(t);
    return pe(s, (r) => n[r]);
  }, false, e);
}
const y = S((s) => {
  if (typeof s == "number")
    return s;
  if (typeof s == "string") {
    const e = Number(s);
    if (!Number.isNaN(e))
      return e;
  }
  throw E();
}, "number"), h = S((s) => {
  if (typeof s == "string" || typeof s == "number")
    return s.toString();
  throw E();
}, "string");
({
  clipboard_text_received: g({
    req_id: h(),
    data: (s) => s === null ? s : h().optional().parse(s)
  }),
  custom_method_invoked: g({
    req_id: h(),
    result: (s) => s,
    error: h().optional()
  }),
  popup_closed: {
    parse(s) {
      return g({
        button_id: (e) => e == null ? void 0 : h().parse(e)
      }).parse(s ?? {});
    }
  },
  viewport_changed: g({
    height: y(),
    width: (s) => s == null ? window.innerWidth : y().parse(s),
    is_state_stable: b(),
    is_expanded: b()
  })
});
const Ee = S((s) => s instanceof Date ? s : new Date(y().parse(s) * 1e3), "Date");
function K(s, e) {
  return new D((t) => {
    if (typeof t != "string" && !(t instanceof URLSearchParams))
      throw E();
    const n = typeof t == "string" ? new URLSearchParams(t) : t;
    return pe(s, (r) => {
      const i = n.get(r);
      return i === null ? void 0 : i;
    });
  }, false, e);
}
const dt = g({
  id: y(),
  type: h(),
  title: h(),
  photoUrl: {
    type: h().optional(),
    from: "photo_url"
  },
  username: h().optional()
}, "Chat").optional(), ne = g({
  addedToAttachmentMenu: {
    type: b().optional(),
    from: "added_to_attachment_menu"
  },
  allowsWriteToPm: {
    type: b().optional(),
    from: "allows_write_to_pm"
  },
  firstName: {
    type: h(),
    from: "first_name"
  },
  id: y(),
  isBot: {
    type: b().optional(),
    from: "is_bot"
  },
  isPremium: {
    type: b().optional(),
    from: "is_premium"
  },
  languageCode: {
    type: h().optional(),
    from: "language_code"
  },
  lastName: {
    type: h().optional(),
    from: "last_name"
  },
  photoUrl: {
    type: h().optional(),
    from: "photo_url"
  },
  username: h().optional()
}, "User").optional();
function Se() {
  return K({
    authDate: {
      type: Ee(),
      from: "auth_date"
    },
    canSendAfter: {
      type: y().optional(),
      from: "can_send_after"
    },
    chat: dt,
    chatInstance: {
      type: h().optional(),
      from: "chat_instance"
    },
    chatType: {
      type: h().optional(),
      from: "chat_type"
    },
    hash: h(),
    queryId: {
      type: h().optional(),
      from: "query_id"
    },
    receiver: ne,
    startParam: {
      type: h().optional(),
      from: "start_param"
    },
    user: ne
  }, "InitData");
}
function ps(s) {
  return Se().parse(s);
}
exports.hashToken = hashToken;
exports.initDataToSearchParams = initDataToSearchParams;
exports.ps = ps;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
//# sourceMappingURL=index-DDmfXTDk.cjs.map
